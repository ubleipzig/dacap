stages:
- prepare
- test
- build
- publish
- docs
- mirror

variables:
  npm_config_cache: ${CI_PROJECT_DIR}/.npm

npm_install:
  stage: prepare
  image:
    name: node:8-alpine
    entrypoint: ["/bin/su", "node", "-c"]
  script:
    - npm run build
  cache:
    key: "${CI_PROJECT_ID}"
    paths:
    - .npm
    - lib
    - node_modules
    - public
    - test
  tags:
    - docker

npm_ci:
  stage: test
  image:
    name: node:8-alpine
    entrypoint: ["/bin/su", "node", "-c"]
  script:
  - npm run ci
  cache:
    key: "${CI_PROJECT_ID}"
    paths:
    - .npm
    - lib
    - public
  tags:
  - docker

npm_pack:
  stage: build
  image:
    name: node:8-alpine
    entrypoint: ["/bin/su", "node", "-c"]
  script:
  - 'echo "//registry.npmjs.org/:_authToken=${NPM_TOKEN}" > ~/.npmrc'
  - npm pack
  cache:
    key: "${CI_PROJECT_ID}"
    paths:
    - .npm
  artifacts:
    name: npm-pack
    paths:
    - '*.tgz'
  tags:
    - docker

docker_build:
  stage: build
  image: docker:latest
  services:
  - docker:dind
  script: |
    docker build --pull \
      --build-arg HTTP_PROXY=${HTTP_PROXY} \
      --build-arg HTTPS_PROXY=${HTTPS_PROXY} \
      --build-arg NO_PROXY=${NO_PROXY} \
      --build-arg http_proxy=${HTTP_PROXY} \
      --build-arg https_proxy=${HTTPS_PROXY} \
      --build-arg no_proxy=${NO_PROXY} \
      -t image \
      .
    docker save --output=image.tar.gz image
  artifacts:
    name: docker-image
    paths:
    - image.tar.gz
  tags:
    - docker

npm_publish:
  stage: publish
  image:
    name: node:8-alpine
    entrypoint: ["/bin/su", "node", "-c"]
  script:
  - 'echo "//registry.npmjs.org/:_authToken=${NPM_TOKEN}" > ~/.npmrc'
  - npm publish *.tgz --access public
  dependencies:
  - npm_pack
  tags:
  - docker
  except:
  - branches
  only:
  - /^release\/*/

docker_publish:
  stage: publish
  image: docker:latest
  services:
  - docker:dind
  script: |
    mkdir -p ~/.docker && echo "$DOCKER_AUTH_CONFIG" >~/.docker/config.json
    export version=`expr ${CI_COMMIT_TAG} ':' 'release/\(.\+\)'`
    export major_version=`expr ${version} ':' '\([^.]\+\)'`
    export minor_version=`expr ${version} ':' '[^.]\+\.\([^.]\+\)'`
    export patch_version=`expr ${version} ':' '[^.]\+\.[^.]\+\.\(.\+\)'`
    docker load --input=image.tar.gz
    docker tag image ubleipzig/dacap:${version}
    docker push ubleipzig/dacap:${version}
    for tag in "latest" "${major_version}" "${major_version}.${minor_version}"; do
      docker tag ubleipzig/dacap:${version} ubleipzig/dacap:${tag}
      docker push ubleipzig/dacap:${tag}
    done
  cache:
    key: "${CI_PROJECT_ID}"
    paths:
    - .npm
  tags:
    - docker
  except:
  - branches
  only:
  - /^release\/*/

gh_pages:
  stage: docs
  image:
    name: squidfunk/mkdocs-material:2.7.2
    entrypoint: [ "/bin/sh", "-c" ]
  only:
  - /^master/
  script: |
    git remote set-url origin https://${GITLAB_USER}:${GITLAB_TOKEN}@git.sc.uni-leipzig.de/ubl/bdd_dev/webmasterei/dacap.git
    mkdocs gh-deploy
  tags:
  - docker
  except:
  - branches
  only:
  - /^release\/*/

github_mirror:
  stage: mirror
  image:
    name: alpine/git
    entrypoint: [ "/bin/sh", "-c" ]
  variables:
    GIT_STRATEGY: clone
    GIT_CHECKOUT: "false"
  script: |
    cd /tmp
    git clone --mirror ${CI_REPOSITORY_URL} project
    cd project
    git remote add github https://${GITHUB_USER}:${GITHUB_TOKEN}@github.com/ubleipzig/dacap.git
    git push --mirror github
  tags:
  - docker
