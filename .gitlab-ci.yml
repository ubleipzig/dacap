stages:
- prepare
- test
- build
- bundle_npm
- build_image
- publish
- deploy
- docs
- mirror

variables:
  npm_config_cache: ${CI_PROJECT_DIR}/.npm

npm_install:
  stage: prepare
  image:
    name: node:10-alpine
    entrypoint: ["/bin/su", "node", "-c"]
  script:
    - npm run build
  cache:
    key: "${CI_PROJECT_ID}"
    paths:
    - .npm
    - lib
    - node_modules
    - public
    - test
  tags:
    - docker

npm_ci:
  stage: test
  image:
    name: node:10-alpine
    entrypoint: ["/bin/su", "node", "-c"]
  script:
  - npm run ci
  cache:
    key: "${CI_PROJECT_ID}"
    paths:
    - .npm
    - lib
    - public
  tags:
  - docker

npm_pack:
  stage: bundle_npm
  image:
    name: node:10-alpine
    entrypoint: ["/bin/su", "node", "-c"]
  script:
  - npm pack
  cache:
    key: "${CI_PROJECT_ID}"
    paths:
    - .npm
  artifacts:
    name: npm-pack
    paths:
    - '*.tgz'
  tags:
    - docker

docker_build:
  stage: build_image
  image: docker:latest
  services:
  - docker:dind
  script: |
    docker build --pull \
      --build-arg HTTP_PROXY=${HTTP_PROXY} \
      --build-arg HTTPS_PROXY=${HTTPS_PROXY} \
      --build-arg NO_PROXY=${NO_PROXY} \
      --build-arg http_proxy=${HTTP_PROXY} \
      --build-arg https_proxy=${HTTPS_PROXY} \
      --build-arg no_proxy=${NO_PROXY} \
      -t image \
      .
    docker save --output=image.tar.gz image
  dependencies:
  - npm_pack
  artifacts:
    name: docker-image
    paths:
    - image.tar.gz
  tags:
    - docker

npm_publish:
  stage: publish
  image:
    name: node:10-alpine
    entrypoint: ["/bin/su", "node", "-c"]
  script:
  - 'echo "//registry.npmjs.org/:_authToken=${NPM_TOKEN}" > ~/.npmrc'
  - npm publish *.tgz --access public
  dependencies:
  - npm_pack
  tags:
  - docker
  except:
  - branches
  only:
  - /^release\/.*/

docker_publish_production:
  stage: publish
  image: docker:latest
  services:
  - docker:dind
  script: |
    mkdir -p ~/.docker && echo "$DOCKER_AUTH_CONFIG" >~/.docker/config.json
    version=`expr ${CI_COMMIT_TAG} ':' 'release/\(.\+\)'`
    major_version=`expr ${version} ':' '\([^.]\+\)'`
    minor_version=`expr ${version} ':' '[^.]\+\.\([^.]\+\)'`
    patch_version=`expr ${version} ':' '[^.]\+\.[^.]\+\.\(.\+\)'`
    docker load --input=image.tar.gz
    docker tag image ubleipzig/dacap:${version}
    docker push ubleipzig/dacap:${version}
    for tag in "latest" "${major_version}" "${major_version}.${minor_version}"; do
      docker tag ubleipzig/dacap:${version} ubleipzig/dacap:${tag}
      docker push ubleipzig/dacap:${tag}
    done
  dependencies:
  - docker_build
  tags:
    - docker
  except:
  - branches
  only:
  - /^release\/.*/

docker_publish_alpha:
  stage: publish
  image: docker:latest
  services:
  - docker:dind
  script: |
    test "${DOCKER_AUTH_CONFIG}" == "" && echo "docker-config does not exists, aborting!" && false
    mkdir -p ~/.docker && echo "$DOCKER_AUTH_CONFIG" >~/.docker/config.json
    docker load --input=image.tar.gz
    docker tag image ubleipzig/dacap:alpha-${CI_COMMIT_REF_NAME}
    docker push ubleipzig/dacap:alpha-${CI_COMMIT_REF_NAME}
  dependencies:
  - docker_build
  tags:
    - docker
  only:
  - /^[0-9]+-/

docker_publish_staging:
  stage: publish
  image: docker:latest
  services:
  - docker:dind
  script: |
    mkdir -p ~/.docker && echo "$DOCKER_AUTH_CONFIG" >~/.docker/config.json
    docker load --input=image.tar.gz
    docker tag image ubleipzig/dacap:staging
    docker push ubleipzig/dacap:staging
  dependencies:
  - docker_build
  tags:
    - docker
  only:
  - master

deploy_alpha:
  stage: deploy
  image: dtzar/helm-kubectl:2.9.1
  variables:
    k8s_namespace: dacap_alpha
    url_schema: https://
    ingress_host: alpha.ub.uni-leipzig.de
    ingress_path: /dacap
  environment:
    name: alpha/${CI_COMMIT_REF_NAME}
    url: https://alpha.ub.uni-leipzig.de/dacap/${CI_COMMIT_REF_NAME}
  script: |
    test "${KUBE_CONFIG}" == "" && echo "kubeconfig does not exists, aborting!" && false
    mkdir ~/.kube && echo "${KUBE_CONFIG}" > ~/.kube/config

    git clone https://git.sc.uni-leipzig.de/ubl/bdd_dev/webmasterei/helm-charts.git/
    cd helm-charts

    if [ "$(helm ls | grep issue-${CI_COMMIT_REF_NAME})" == "" ];then
      echo "Release not installed. Installing..."
      helm install -n issue-${CI_COMMIT_REF_NAME} \
        --namespace dacap-alpha \
        --set environment.proxy_url=${url_schema}${ingress_host}${ingress_path}/${CI_COMMIT_REF_NAME}/ \
        --set environment.http_proxy=http://proxy.uni-leipzig.de:3128 \
        --set ingress.path=${ingress_path}/${CI_COMMIT_REF_NAME} \
        --set ingress.hosts[0]=${ingress_host} \
        --set image.tag=alpha-${CI_COMMIT_REF_NAME} \
        --set pullPolicy=Always \
        ./dacap/
    else
      echo "Release already installed. Upgrading..."
      helm upgrade issue-${CI_COMMIT_REF_NAME} \
        --recreate-pods \
        --reuse-values \
        --set foo=bar \
        ./dacap/
    fi

    echo "Waiting for successful deploy..."
    counter=0
    while [ "$(helm ls | grep issue-${CI_COMMIT_REF_NAME} | awk -F"\t" '{ print $4; }')" != "DEPLOYED" ]; do
      sleep 1
      if [ $counter -eq 60 ];then break && false; fi
      counter=$[$counter+1];
    done
  dependencies:
  - docker_publish_alpha
  tags:
  - docker
  only:
  - /^[0-9]+-/
  except:
  - tags

gh_pages:
  stage: docs
  image:
    name: squidfunk/mkdocs-material:2.7.2
    entrypoint: [ "/bin/sh", "-c" ]
  script: |
    git remote set-url origin https://${GITLAB_USER}:${GITLAB_TOKEN}@git.sc.uni-leipzig.de/ubl/bdd_dev/webmasterei/dacap.git
    mkdocs gh-deploy
  tags:
  - docker
  except:
  - branches
  only:
  - /^release\/.*/

github_mirror:
  stage: mirror
  image:
    name: alpine/git
    entrypoint: [ "/bin/sh", "-c" ]
  variables:
    GIT_STRATEGY: clone
    GIT_CHECKOUT: "false"
  script: |
    cd /tmp
    git clone --mirror ${CI_REPOSITORY_URL} project
    cd project
    git remote add github https://${GITHUB_USER}:${GITHUB_TOKEN}@github.com/ubleipzig/dacap.git
    git push --mirror github
  tags:
  - docker
